# Commodore Peripheral Bus: Part 1: IEEE-488

In the series about the variants of Commodore Peripheral Bus family, this article covers the lowest two layers (electrical and byte transfer) of the IEEE-488 bus as found on the PET/CBM series.

![](docs/cbmbus/ieee-488_layers.png =211x241)

## History

Most other computers from the early time of home/personal computers had printers connected through either Centronics or RS-232 and disk drives connected directly to the internal bus. For the 1977 PET, their first computer, Commodore decided to go with a standard interface that would allow to connect several drives and printers a single port: IEEE-488. The interface standardized as IEEE-488 in the USA and as IEC-625 internationally is also known as the Hewlett-Packard Interface Bus ("HP-IB") and is originally from the late 1960s. It was popular mostly for test equipment, but also for printers.

IEEE-488 is a 8 bit parallel bus with the following properties:

* All participants are **daisy-chained**.
* **One dedicated controller** (the computer) does bus arbitration of **up to 31 devices**.
* **One-to-many**: Any participant can send data to any set of participants.
* A device has **multiple channels** for different functions.
* Data transmission is **byte stream** based.

This article covers IEEE-488 from the PET's perspective. Differences to the standard are mentioned at the end.

## Layer 1: Electrical

### Connectors and Pinout

On the computer side, the PET uses a proprietary 24 pin board connector:

![](docs/cbmbus/ieee-488_board_connector.svg =400x126)

All devices use the standardized IEEE-488 connector, which is a 24 pin micro ribbon connector:

![](docs/cbmbus/micro_ribbon_24.svg =400x85)

Devices usually only have a single micro ribbon connector, but the connectors of common IEEE-488 cables have one male and one female side, so the back side of every cable connector becomes the connector to the next device.

XXX TODO picture

The pinout is similar across the two connectors:

| Pin | Signal | Description        | Pin   | Signal | Description        |
|-----|--------|--------------------|-------|--------|--------------------|
| 1   | DIO1   | Data I/O           | 13/A  | DIO5   | Data I/O           |
| 2   | DIO2   | Data I/O           | 14/B  | DIO6   | Data I/O           |  
| 3   | DIO3   | Data I/O           | 15/C  | DIO7   | Data I/O           |
| 4   | DIO4   | Data I/O           | 16/D  | DIO8   | Data I/O           |
| 5   | EOI    | End Or Identify    | 17/E  | REN    | Remote Enable      |
| 6   | DAV    | Data Valid         | 18/F  | GND    |                    |
| 7   | NRFD   | Not Ready For Data | 19/H  | GND    |                    |
| 8   | NDAC   | No Data Accepted   | 20/J  | GND    |                    |
| 9   | IFC    | Interface Clear    | 21/K  | GND    |                    |
| 10  | SRQ    | Service Request    | 22/L  | GND    |                    |
| 11  | ATN    | Attention          | 23/M  | GND    |                    |
| 12  | SHIELD |                    | 24/N  | GND    |                    |     

* The eight DIO lines carry the data bytes.
* The NRFD, DAV and NDAC lines are used to perform handshaking.
* EOI, ATN, SRC and REN are control lines.
* IFC is the RESET line for all devices.

### Open Collector Logic

All signal lines are TTL open collector, which means:
* All participants of the bus can not only read, but also write to the line.
* When **all** participants write 0, the line will read back 0, but if any device writes 1, the bus will read back as 1.
* The logic is inverted: 5V is 0 (false), and 0V is 1 (true).

In other words: If the line is *released* by all bus participants, it will be 5V or logically 0, and any participant can *pull* it to 0V or logically 1.

This can be visualized with two hands that can pull the line to 1, and a spring that pushes it to 0:

![](docs/cbmbus/open_collector.gif =302x162)

So when a line reads as 0, it is known that it is currently released by all participants, but if a line reads as 1, it is impossible to know who or even how many are currently pulling it.

## Layer 2: Byte Transfer

IEEE-488 defines transmissions of byte streams. For every byte stream, there is one sender and one or more receivers. Any number of additional bus participant can remain silent.

In order to define which participant is the sender, TODO

### Sending a Byte

The sender operates the DIO (Data I/O) and DAV (Data Valid) lines, while the receivers operate the NRFD (Not Ready For Data) and NDAC (Not Data Accepted) lines. All bus participants that don't operate a line leave it released.

The basic idea is that the receivers signal that they are ready for data (NRFD = 0), the sender puts the data on the bus (DIO) and signals that the data is valid (DAV), and the receivers signal that they have accepted the data (NDAC = 0).

The following animation shows a byte being sent to two receivers.

![](docs/cbmbus/ieee-488.gif =601x577)

Let's go through it step by step:

#### 0: Initial State: Receivers are busy
![](docs/cbmbus/ieee-488-01.png =601x256)
In the initial state, the sender has the 8 data bits set to 0 and DAV to 0, meaning that there is no data available. All receivers have NDAC pulled, meaning that no data was accepted (yet). They may also have NRFD (not ready for data) pulled while they are busy doing other things.  

#### 1: A is now ready to receive data
![](docs/cbmbus/ieee-488-02.png =601x256)
Transmission of a byte cannot begin until all receivers are ready to receive. So at some point the first receiver is done handling the previous byte it may have received and signals that it is ready for data by releasing NRFD. The wire NRFD is still pulled by the other receiver though, so its value is still 1.

#### 2: All receivers are now ready to receive data
![](docs/cbmbus/ieee-488-03.png =601x256)
Whenever the other receiver is ready to receive the next byte, it will also release NRFD, so it will now ready back as 0: All receivers are ready to receive data.

#### 3: Sender puts data on the bus
![](docs/cbmbus/ieee-488-04.png =601x256)
Triggered by NRFD being 0, the sender now puts the byte value onto DIO.

#### 4: Data on bus is now valid
![](docs/cbmbus/ieee-488-05.png =601x256)
After that, the sender pulls DAV, signaling that the data in DIO is valid.

#### 5: A is now busy again
![](docs/cbmbus/ieee-488-06.png =601x256)
Triggered by DAV being 1, the receivers first have to signal that they are busy, so that after accepting the data, the sender wouldn't think the receivers are immediately ready for the next byte. So now, the first receiver pulls NRFD, so NRFD is 1.

#### 6: A has accepted the data
![](docs/cbmbus/ieee-488-07.png =601x256)
Then, the first receiver reads the data from DIO and releases NDAC, signaling that it has accepted the data. But the other receiver is still pulling it, so NDAC is still 1.

#### 7: B is now busy
![](docs/cbmbus/ieee-488-08.png =601x256)
Before it can accept the data, the other receiver also has to signal that it is busy by pulling NRFD. The line was already 1 and will stay at 1.

#### 8: All receivers have accepted the data
![](docs/cbmbus/ieee-488-09.png =601x256)
Then the other receiver reads the data from DIO and releases NDAC. NDAC is now 0, meaning all receivers have accepted the data.

#### 9: Data on the bus is no longer valid
![](docs/cbmbus/ieee-488-10.png =601x256)
Triggered by NDAC being 0, the sender sents DAV back to 0, meaning the data in DIO is no longer valid.

#### 10: Sender clears data on the bus
![](docs/cbmbus/ieee-488-11.png =601x256)
In order to revert to the initial state, the sender then clears the byte from the DIO lines and sets them back to 0.

#### 11: A resets data accepted
![](docs/cbmbus/ieee-488-12.png =601x256)
Triggered by DAV being 0, the first receiver pulls NDAC.

#### 12: B resets data accepted
![](docs/cbmbus/ieee-488-13.png =601x256)
Likewise, the other receiver pulls NDAC. All wires are now in the initial state again. All steps are repeated as long as there is more data to be sent.

Note that the protocol only specifies the triggers: For example, the receivers are to read the data from DIO once DAV = 1, so it would be just as legal for the the sender to put the data on DIO earlier.

Also, there is no ordering on which receiver pulls or releases its line first. The receivers don't care about the other receivers, they only follow the protocol with the sender. The open collector property of the signal lines automatically combines the outputs of the different receivers.

### End of Stream

The first step in the cycle of transmitting a byte is always done by the receivers: They signal that they are ready for data. If there is no more data to be transmitted, the receivers must not start the cycle: The "initial state" with DAV = 0, DIO = 0 NRFD = 1 and NDAC = 1 is the stable state between transmission sessions.

In order for the receivers to know that there is no more data on its way, the sender needs to tell them while it is transmitting the last byte. It does this by pulling the EOI line to 1 during the same time that it pulls DAV to 1.

A side effect of this is that an IEEE-488 software implementation with a "send byte" function and a "end stream" function has to always cache the byte passed to "send byte" because it cannot know whether it's the last one yet. So when sending a byte, it sends the previously cached byte and caches the new one, and when ending the stream, it sends the cached byte while pulling EOI.

### ATN

* controller and command bytes
	* just this supports the use case of one device that is always the sender, and plus some devices which are only receivers
		* e.g with a computer and a printer or a disk copy station with one source and one or many destinations
	* one device needs to be the designated "controller"
	
	* controller can interrupt the bus at any time
		* XXX probably only when 
	* sends one control byte
		* controller pulls ATN
		* controller sends 1 byte
		* *all* other devices receive control byte
		* controller releases ATN

### Bus Turnaround

* it's not fixed who's a sender and who's a receiver
* they're only assigned for one stream
* new assignments for next stream
* e.g.
	* A sends 10 bytes to B and C
	* then B sends 5 bytes to A

* XXX what happens when a stream is done? who releases what?
	* receivers probably release NRFD and NDAC -> whole bus idle

* sender becomes receiver (secondary after talk)
	* while ATN pulled
	* pull NRFD and NDAC
	* release ATN
		
### Errors

When the sender wants to start the transmission of a byte, the bus must be in one of these two states:

* NRFD = 1, NDAC = X: At least one receiver is still busy, so wait until everyone is ready for data.
* NRFD = 0, NDAC = 1: All receivers are ready for data.

If NRFD = 0 and NDAC = 0, this means that there are no receivers present.

* There are either no other participants connected at all, and since the sender is not pulling NRFD or NDAC, they are both 0,
* or there are participants connected, but they don't want to receive, so they aren't pulling NRFD or NDAC.

Receivers cannot detect whether there is a sender though. When trying to receive the first byte, the receivers signal their readiness with NRFD = 0. Then, as long as DAV = 0, it means the sender doesn't have new data yet, and as soon as DAV = 1, it means the sender has data. The single line owned by the sender cannot communicate that there is nobody willing to send.

* timeout (Commodore extension)
	* receiver timeout: if data not accepted within 64 us
	* sender timeout: if data not available within 64 us
	* for compatibility with IEEE, this can be disabled (SETTMO #$80)

### Timing

* no timing requirements!
* slowest device defines speed
	* anyone can pause at any time
	* great for CPUs that have other things to do as well
	* IRQs remain on, NMIs and DMA okay
* Commodore
	* timeouts, so it can detect that sender has no data
	* implicit communication through timing!

### Commodore

* features not implemented on CBM devices
	* multiple controllers
	* SRQ
	* polling
	* etc.
* PET has all lines (except REN), so a program can do real IEEE-488
* Timeouts

