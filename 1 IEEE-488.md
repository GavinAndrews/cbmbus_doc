# Commodore Peripheral Bus: Part 1: IEEE-488

In the series about the variants of Commodore Peripheral Bus family, this article covers the lowest two layers (electrical and byte transfer) of the IEEE-488 bus as found on the PET/CBM series.

![](docs/cbmbus/ieee-488_layers.png =211x241)

## History

Most other computers from the early time of home/personal computers had printers connected through either Centronics or RS-232 and disk drives connected directly to the internal bus. For the 1977 PET, their first computer, Commodore decided to go with a standard interface that would allow to connect several drives and printers a single port: IEEE-488. The interface standardized as IEEE-488 in the USA and as IEC-625 internationally is also known as the Hewlett-Packard Interface Bus ("HP-IB") and is originally from the late 1960s. It was popular mostly for test equipment, but also for printers.

IEEE-488 is a 8 bit parallel bus with the following properties:

* All participants are **daisy-chained**.
* **One dedicated controller** (the computer) does bus arbitration of **up to 31 devices**.
* **One-to-many**: Any participant can send data to any set of participants.
* A device has **multiple channels** for different functions.
* Data transmission is **byte stream** based.

This article covers IEEE-488 from the PET's perspective. Differences to the standard are mentioned at the end.

## Layer 1: Electrical

### Connectors and Pinout

On the computer side, the PET uses a proprietary 24 pin board connector:

![](docs/cbmbus/ieee-488_board_connector.svg =400x126)

All devices use the standardized IEEE-488 connector, which is a 24 pin micro ribbon connector:

![](docs/cbmbus/micro_ribbon_24.svg =400x85)

Devices usually only have a single micro ribbon connector, but the connectors of common IEEE-488 cables have one male and one female side, so the back side of every cable connector becomes the connector to the next device.

XXX TODO picture

The pinout is similar across the two connectors:

| Pin | Signal | Description        | Pin   | Signal | Description        |
|-----|--------|--------------------|-------|--------|--------------------|
| 1   | DIO1   | Data I/O           | 13/A  | DIO5   | Data I/O           |
| 2   | DIO2   | Data I/O           | 14/B  | DIO6   | Data I/O           |  
| 3   | DIO3   | Data I/O           | 15/C  | DIO7   | Data I/O           |
| 4   | DIO4   | Data I/O           | 16/D  | DIO8   | Data I/O           |
| 5   | EOI    | End Or Identify    | 17/E  | REN    | Remote Enable      |
| 6   | DAV    | Data Valid         | 18/F  | GND    |                    |
| 7   | NRFD   | Not Ready For Data | 19/H  | GND    |                    |
| 8   | NDAC   | No Data Accepted   | 20/J  | GND    |                    |
| 9   | IFC    | Interface Clear    | 21/K  | GND    |                    |
| 10  | SRQ    | Service Request    | 22/L  | GND    |                    |
| 11  | ATN    | Attention          | 23/M  | GND    |                    |
| 12  | SHIELD |                    | 24/N  | GND    |                    |     

* The eight DIO lines carry the data bytes.
* The NRFD, DAV and NDAC lines are used to perform handshaking.
* EOI, ATN, SRC and REN are control lines.
* IFC is the RESET line for all devices.

### Open Collector Logic

All signal lines are TTL open collector, which means:
* All participants of the bus can not only read, but also write to the line.
* When **all** participants write 0, the line will read back 0, but if any device writes 1, the bus will read back as 1.
* The logic is inverted: 5V is 0, and 0V is 1.

In other words: If the line is *released* by all bus participants, it will be 5V or logically 0, and any participant can *pull* it to 0V or logically 1.

This can be visualized with two hands that can pull the line to 1, and a spring that pushes it to 0:

![](docs/cbmbus/open_collector.gif =302x162)

So when a line reads as 0, it is known that it is currently released by all participants, but if a line reads as 1, it is impossible to know who or even how many are currently pulling it.

## Layer 2: Byte Transfer

Byte transfer is done using the 8 DIO lines and the 3 handshake lines. The protocol allows at any given time any participant to send a byte stream to any number of participants (but at least one), with any number of passive participants on the bus remaining silent.

The sender will put the data into the DIO lines and operate the DAV (Data Valid) line, while the receivers operate the NRFD (Not Ready For Data) and NDAC (Not Data Accepted) lines.

The open collector property of all lines means that the bus participants that don't operate a line will leave it released.

### Sending a Byte

The following animation shows a byte being sent to two receivers.

![](docs/cbmbus/ieee-488.gif =601x577)


#### 0: Initial State: Receivers are busy
![](docs/cbmbus/ieee-488-01.png =601x256)
In the initial state, the sender has the 8 data bits set to 0 and DAV to 0, meaning that there is no data available. All receivers have NDAC pulled, meaning that no data was accepted (yet). They may also have NRFD (not ready for data) pulled while they are busy doing other things.  

#### 1: A is now ready to receive data
![](docs/cbmbus/ieee-488-02.png =601x256)
Transmission of a byte cannot begin until all receivers are ready to receive. So at some point the first receiver is done handling the previous byte it may have received and signals that it is ready for data by releasing NRFD. The wire NRFD is still pulled by the other receiver though, so its value is still 1.

#### 2: All receivers are now ready to receive data
![](docs/cbmbus/ieee-488-03.png =601x256)
Whenever the other receiver is ready to receive the next byte, it will also release NRFD, so it will now ready back as 0: All receivers are ready to receive data.

#### 3: Sender puts data on the bus
![](docs/cbmbus/ieee-488-04.png =601x256)
Triggered by NRFD being 0, the sender now puts the byte value onto DIO.

#### 4: Data on bus is now valid
![](docs/cbmbus/ieee-488-05.png =601x256)
After that, the sender pulls DAV, signaling that the data in DIO is valid.

#### 5: A is now busy again
![](docs/cbmbus/ieee-488-06.png =601x256)
Triggered by DAV being 1, the receivers first have to signal that they are busy, so that after accepting the data, the sender wouldn't think the receivers are immediately ready for the next byte. So now, the first receiver pulls NRFD, so NRFD is 1.

#### 6: A has accepted the data
![](docs/cbmbus/ieee-488-07.png =601x256)
Then, the first receiver reads the data from DIO and releases NDAC, signaling that it has accepted the data. But the other receiver is still pulling it, so NDAC is still 1.

#### 7: B is now busy
![](docs/cbmbus/ieee-488-08.png =601x256)
Before it can accept the data, the other receiver also has to signal that it is busy by pulling NRFD. The line was already 1 and will stay at 1.

#### 8: All receivers have accepted the data
![](docs/cbmbus/ieee-488-09.png =601x256)
Then the other receiver reads the data from DIO and releases NDAC. NDAC is now 0, meaning all receivers have accepted the data.

#### 9: Data on the bus is no longer valid
![](docs/cbmbus/ieee-488-10.png =601x256)
Triggered by NDAC being 0, the sender sents DAV back to 0, meaning the data in DIO is no longer valid.

#### 10: Sender clears data on the bus
![](docs/cbmbus/ieee-488-11.png =601x256)
In order to revert to the initial state, the sender then clears the byte from the DIO lines and sets them back to 0.

#### 11: A resets data accepted
![](docs/cbmbus/ieee-488-12.png =601x256)
Triggered by DAV being 0, the first receiver pulls NDAC.

#### 12: B resets data accepted
![](docs/cbmbus/ieee-488-13.png =601x256)
Likewise, the other receiver pulls NDAC. All wires are now in the initial state again. All steps are repeated as long as there is more data to be sent.

### The End of a Byte Stream

The first step in the cycle of transmitting a byte is always done by the receivers: They signal that they are ready for data. If there is no more data to be transmitted, the receivers must not start the cycle: The "initial state" with DAV = 0, DIO = 0 NRFD = 1 and NDAC = 1 is the stable state between transmission sessions.

In order for the receivers to know that there is no more data on its way, the sender needs to tell them while it is transmitting the last byte. It does this by pulling the EOI line to 1 during the same time that it pulls DAV to 1.

A side effect of this is that an IEEE-488 software implementation with a "send byte" function and a "end stream" function has to always cache the byte passed to "send byte" because it cannot know whether it's the last one yet. So when sending a byte, it sends the previously cached byte and caches the new one, and when ending the stream, it sends the cached byte while pulling EOI.

### Errors

* no receivers present
	* if there is no receiver, NDAC *and* NRFD are released
		* this can be detected by sender at "start"
	* XXX if there is no sender?
		* can't be detected?
* timeout (Commodore extension)
	* receiver timeout: if data not accepted within 64 us
	* sender timeout: if data not available within 64 us
	* for compatibility with IEEE, this can be disabled (SETTMO #$80)

### Bus Turnaround

* sender becomes receiver (secondary after talk)
	* while ATN pulled
	* pull NRFD and NDAC
	* release ATN
		
### Timing

* no timing requirements!
* slowest device defines speed
	* anyone can pause at any time
	* great for CPUs that have other things to do as well
	* IRQs remain on, NMIs and DMA okay
* Commodore
	* timeouts, so it can detect that sender has no data
	* implicit communication through timing!

### Commodore

* features not implemented on CBM devices
	* multiple controllers
	* SRQ
	* polling
	* etc.
* PET has all lines (except REN), so a program can do real IEEE-488


* controller and command bytes
	* just this supports the use case of one device that is always the sender, and plus some devices which are only receivers
		* e.g with a computer and a printer or a disk copy station with one source and one or many destinations
	* one device needs to be the designated "controller"
	
	* controller can interrupt the bus at any time
	* sends one control byte
		* controller pulls ATN
		* controller sends 1 byte
		* *all* other devices receive control byte
		* controller releases ATN

* SRQ and REN
	* TODO

