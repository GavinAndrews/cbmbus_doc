# Commodore Peripheral Bus: Part 1: IEEE-488

In the series about the variants of Commodore Peripheral Bus family, this article covers the lowest two layers of the IEEE-488 bus as found on the PET and the CBM-II series.

![](docs/cbmbus/ieee-488_layers.png =211x241)

## History

Released in 1977, the PET was Commodore's first computer. For connecting floppy drives, hard drives, printers and plotters, the designers decided to go with an existing bus specification: The Hewlett-Packard Interface Bus ("HP-IB") from the late 1960s, which was later standardized as IEEE-488 in the USA and as IEC-625 internationally, which was already popular for test equipment, but also for printers. This article covers IEEE-488 from the PET's perspective. Differences to the standard are mentioned at the end.

IEEE-488 is a 8 bit parallel bus with the following properties:

* All participants are **daisy-chained**.
* **One dedicated controller** (the computer) does bus arbitration of **up to 31 devices**.
* **One-to-many**: Any participant can send data to any set of participants.
* A device has **multiple channels** for different functions.
* Data transmission is **byte stream** based.

## Electrical Layer

### Connectors and Pinout

On the computer side, the PET uses a proprietary 24 pin board connector:

![](docs/cbmbus/ieee-488_board_connector.svg =400x126)

All devices use the standardized IEEE-488 connector, which is a 24 pin micro ribbon connector:

![](docs/cbmbus/micro_ribbon_24.svg =400x85)

Devices usually only have a single micro ribbon connector, but the connectors of common IEEE-488 cables have one male and one female side, so the back side of every cable connector becomes the connector to the next device.

XXX TODO picture

The pinout is similar across the two connectors:

| Pin | Signal | Description        | Pin   | Signal | Description        |
|-----|--------|--------------------|-------|--------|--------------------|
| 1   | DIO1   | Data I/O           | 13/A  | DIO5   | Data I/O           |
| 2   | DIO2   | Data I/O           | 14/B  | DIO6   | Data I/O           |  
| 3   | DIO3   | Data I/O           | 15/C  | DIO7   | Data I/O           |
| 4   | DIO4   | Data I/O           | 16/D  | DIO8   | Data I/O           |
| 5   | EOI    | End Or Identify    | 17/E  | REN    | Remote Enable      |
| 6   | DAV    | Data Valid         | 18/F  | GND    |                    |
| 7   | NRFD   | Not Ready For Data | 19/H  | GND    |                    |
| 8   | NDAC   | No Data Accepted   | 20/J  | GND    |                    |
| 9   | IFC    | Interface Clear    | 21/K  | GND    |                    |
| 10  | SRQ    | Service Request    | 22/L  | GND    |                    |
| 11  | ATN    | Attention          | 23/M  | GND    |                    |
| 12  | SHIELD |                    | 24/N  | GND    |                    |     

Here's a rough overview of the purpose of the wires:

* The eight DIO lines carry the data bytes.
* The NRFD, DAV and NDAC lines are used to perform handshaking.
* EOI, ATN, SRC and REN are control lines.
* IFC is the RESET line for all devices.

### Open Collector Logic

All signal lines are TTL open collector, which means that they default to 5V, and can be "pulled" to 0V by any participant on the bus. So if one or more participants pull the line, it will be at 0V, otherwise it will be at 5V. The naming can be inconsistent and confusing, so here is an overview:

| Voltage |          |            |          | Logical |
|---------|----------|-----------------------|---------|
| 0V      | pulled   | asserted   | active   | 1       |
| 5V      | released | unasserted | inactive | 0       |

Note that 0V is logical 1 and 5V is logical 0. So a wire defaults to 0 and any participant can set it to 1.

It is important to understand that it is impossible to tell which participant pulled a line to 1, or whether it is one or more participants currently pulling it.

## Byte Transfer Layer

Byte transfer is done using the 8 DIO lines and the 3 handshake lines. The protocol allows at any given time any participant to send a byte stream to any number of participants (but at least one), with any number of passive participants on the bus remaining silent.

The sender will put the data into the DIO lines and operate the DAV (Data Valid) line, while the receivers operate the NRFD (Not Ready For Data) and NDAC (Not Data Accepted) lines.

The open collector property of all lines means that the bus participants that don't operate a line will leave it released.

### Sending a Byte

The following animation shows a byte being sent to two receivers.

![](docs/cbmbus/ieee-488.gif =601x577)

* **0: Initial State: Receivers are busy**
  In the initial state, the sender sets the 8 data bits to 0 and DAV to 0, meaning that there is no data available. All receivers pull NDAC, meaning that no data was accepted (yet). They may also pull NRFD (not ready for data) while they are busy doing other things.  
* **1: A is now ready to receive data**
  Transmission of a byte cannot begin until all receivers are ready to receive. So at some point the first receiver is done handling the previous byte it may have received and signals that it is ready for data by releasing NRFD. The wire NRFD is still pulled by the other receiver though, so its value is still 1.
* **2: All receivers are now ready to receive data**
  Whenever the other receiver is ready to receive the next byte, it will also release NRFD, so it will now ready back as 0: All receivers are ready to receive data.
* **3: Sender puts data on the bus**
  Triggered by NRFD being 0, the sender now puts the byte value onto DIO.
* **4: Data on bus is now valid**
  After that, the sender pulls DAV, signaling that the data in DIO is valid.
* **5: is now busy again**
  Triggered by DAV being 1, the receivers first have to signal that they are busy, so that after accepting the data, the sender wouldn't think the receivers are immediately ready for the next byte. So now, the first receiver pulls NRFD, so NRFD is 1.
* **6: A has accepted the data**
  Then, the first receiver reads the data from DIO and releases NDAC, signaling that it has accepted the data. But the other receiver is still pulling it, so NDAC is still 1.
* **7: B is now busy**
  Before it can accept the data, the other receiver also has to signal that it is busy by pulling NRFD. The line was already 1 and will stay at 1.
* **8: All receivers have accepted the data**
  Then the other receiver reads the data from DIO and releases NDAC. NDAC is now 0, meaning all receivers have accepted the data.
* **9: Data on the bus is no longer valid**
  Triggered by NDAC being 0, the sender sents DAV back to 0, meaning the data in DIO is no longer valid.
* **10: Sender clears data on the bus**
  In order to revert to the initial state, the sender then clears the byte from the DIO lines and sets them back to 0.
* **11: A resets data accepted**
  Triggered by DAV being 0, the first receiver pulls NDAC.
* **12: B resets data accepted**
  Likewise, the other receiver pulls NDAC. All wires are now in the initial state again.

### EOI

* EOI
	* EOI pulled by sender while data is valid

### Errors

* device not present
	* if there is no receiver, NDAC *and* NRFD are released
		* this can be detected by sender at "start"
	* XXX if there is no sender?
		* can't be detected?
* timeout (Commodore extension)
	* receiver timeout: if data not accepted within 64 us
	* sender timeout: if data not available within 64 us
	* for compatibility with IEEE, this can be disabled (SETTMO #$80)

### Bus Turnaround

* sender becomes receiver (secondary after talk)
	* while ATN pulled
	* pull NRFD and NDAC
	* release ATN
		

* comments:
	* no timing requirements!
	* slowest device defines speed
		* anyone can pause at any time
		* great for CPUs that have other things to do as well
		* IRQs remain on, NMIs and DMA okay
	* Commodore
		* timeouts, so it can detect that sender has no data
		* implicit communication through timing!

* Commodore
	* features not implemented on CBM devices
	    * multiple controllers
	    * SRQ
	    * polling
	    * etc.
	* PET has all lines (except REN), so a program can do real IEEE-488
	* BASIC doesn't have all features though
	    * SRQ
	    * REN
	    * 00xxxxx commands


* controller and command bytes
	* just this supports the use case of one device that is always the sender, and plus some devices which are only receivers
		* e.g with a computer and a printer or a disk copy station with one source and one or many destinations
	* one device needs to be the designated "controller"
	
	* controller can interrupt the bus at any time
	* sends one control byte
		* controller pulls ATN
		* controller sends 1 byte
		* *all* other devices receive control byte
		* controller releases ATN

* SRQ and REN
	* TODO

