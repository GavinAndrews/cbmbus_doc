# Part 1: IEEE-488

In the series about the variants of Commodore Peripheral Bus family, this article covers the lowest two layers of the IEEE-488 bus as found on the PET and the CBM-II series.

![](docs/cbmbus/ieee-488_layers.png =211x241)

## History

Released in 1977, the PET was Commodore's first computer. For connecting floppy drives, hard drives, printers and plotters, the designers decided to go with an existing bus specification: The Hewlett-Packard Interface Bus ("HP-IB") from the late 1960s, which was later standardized as IEEE-488 in the USA and as IEC-625 internationally, was already popular for measuring instruments, but also for printers.

# Electrical Layer

* TTL
* 24 pin Centronics or 24 pin board connector
* Data
	* DIO1-8
* Handshake
	* NRFD
	* DAV
	* NDAC
* Protocol
	* IFC (RESET)
	* ATN
	* SRQ
	* REN (remote enable, grounded on PET "to prevent remote devices from returning to local control")
	* EOI

.

         1  2  3  4  5  6  7  8  9 10 11 12   
      +--o--o--o--o--o--o--o--o--o--o--o--o--+
      |                                      |
       +-o--o--o--o--o--o--o--o--o--o--o--o-+ 
        13 14 15 16 17 18 19 20 21 22 23 24   

      Pin Signal                   Pin Signal
       01: DIO1(Data Input/Output)  13: DIO5(Data Input/Output)
       02: DIO2(Data Input/Output)  14: DIO6(Data Input/Output)
       03: DIO3(Data Input/Output)  15: DIO7(Data Input/Output)
       04: DIO4(Data Input/Output)  16: DIO8(Data Input/Output)
       05: EOI(End Or Identify)     17: REN(Remote ENable)
       06: DAV(DAta Valid)          18: GND (for DAV)
       07: NRFD(Not Ready For Data) 19: GND (for NRFD)
       08: NDAC(No Data ACcepted)   20: GND (for NDAC)
       09: IFC(InterFace Clear)     21: GND (for IFC)
       10: SRQ(Service ReQuest)     22: GND (for SRQ)
       11: ATN(ATteNtion)           23: GND (for ATN)
       12: SHIELD                   24: Signal GND              
      

         1  2  3  4  5  6  7  8  9 10 11 12   
      +--o--o--o--o--o--o--o--o--o--o--o--o--+
      |                                      |
      +--o--o--o--o--o--o--o--o--o--o--o--o--+
         A  B  C  D  E  F  H  J  K  L  M  N
      
      Pin  Signal       Pin Signal
       1   DIO 1         A   DIO 5
       2   DIO 2         B   DIO 6
       3   DIO 3         C   DIO 7
       4   DIO 4         D   DIO 8
       5   EOI           E   REN  
       6   DAV           F   GND  
       7   NRFD          H   GND  
       8   NDAC          J   GND  
       9   IFC           K   GND  
      10   SRQ           L   GND  
      11   ATN           M   GND  
      12   CHASSIS GND   N   GND  


* IFC is RESET
* all other lines are open collector
	* defaults to 5V (line is "incative")
	* will be 0V if any device pulls it down ("asserts" it, line is "active")
	* it's impossible to tell who pulls it down
	* for data, pulled = 0V = logical 1

* transfering bytes
	* bus is byte oriented
	* 8-bit parallel
		* 8 bit data DIO1-DIO8
	* one sender
		* puts data on DIO and participates in handshake
	* any number of receivers
		* read data off DIO and participate in handshake
	* any number of passive devices
		* will leave everything alone
	* send byte: three-wire-handshake
		* ownership
			* DIO1-8 and DAV is owned by the sender
			* NDAC and NRFD are owned by the receivers
			* lines that are not owned are released
		* initial state
			* sender releases DAV (data not available)
			* every receiver pulls NDAC (not all receivers have accepted the data)
			* every receiver pulls NRFD (not all receivers are ready for data)
		* as soon as a receiver is no longer busy
			* release NRFD (receiver is ready for data)
			* as soon as all receivers do this, NRFD is released
		* sender waits for NRFD to be released
		* sender puts inverted data byte on DIO
			* (inverted because pulled is logical 1)
		* sender pulls DAV (data is available)
		* receiver waits for DAV
		* receiver gets inverted data byte from DIO
		* receiver pulls NRFD (receiver is not ready for data)
			* this is the default state for a receiver so the sender doesn't continue
			  with the next byte until the receiver has done something with the data
		* receiver releases NDAC (receiver has accepted the data)
			* as soon as all receivers do this, NDAC is released
		* sender releases DAV (data is not available)
		* sender sets data to $00 (all DIO lines are released)
		* receiver waits for DAV to be released
		* receiver pulls NDAC (receiver has not accepted data)
		* we're in the original state again
	* errors
		* device not present
			* if there is no receiver, NDAC *and* NRFD are released
				* this can be detected by sender at "start"
			* XXX if there is no sender?
				* can't be detected?
		* timeout (Commodore extension)
			* receiver timeout: if data not accepted within 64 us
			* sender timeout: if data not available within 64 us
			* for compatibility with IEEE, this can be disabled (SETTMO #$80)
	* EOI
		* EOI pulled by sender while data is valid
	* bus turnaround
		* sender becomes receiver (secondary after talk)
			* while ATN pulled
			* pull NRFD and NDAC
			* release ATN
		* receiver becomes sender
			* TODO
			
	
	* comments:
		* no timing requirements!
		* slowest device defines speed
			* anyone can pause at any time
			* great for CPUs that have other things to do as well
			* IRQs remain on, NMIs and DMA okay
		* Commodore
			* timeouts, so it can detect that sender has no data
			* implicit communication through timing!

![](docs/cbmbus/ieee-488.gif =601x577)

* controller and command bytes
	* just this supports the use case of one device that is always the sender, and plus some devices which are only receivers
		* e.g with a computer and a printer or a disk copy station with one source and one or many destinations
	* one device needs to be the designated "controller"
	
	* controller can interrupt the bus at any time
	* sends one control byte
		* controller pulls ATN
		* controller sends 1 byte
		* *all* other devices receive control byte
		* controller releases ATN

* SRQ and REN
	* TODO

